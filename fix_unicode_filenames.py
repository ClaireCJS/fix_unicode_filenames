"""
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***
     *** SAVE CODE CHANGES TO A .SAVETEXT FILE FIRST AND CHECK ENCODING BEFORE OVERWRITING!!! IT IS VERY EASY TO CORRUPT THIS FILE!!! TOO EASY!!! ***


    Coverts Unicode/non-ASCII filenames into ASCII filenames -- "Romanizing-Plus"

    USAGE:

        SETUP: To suppress user prompting: set AUTOMATIC_UNICODE_CLEANING=1

        MODE 1:  No      arguments  : Run with no arguments to cleanse everything in your existing folder of unicode characters
              :  "auto"  argum
              ent   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Do this, but suppress confirmation prompts
        MODE 2: "file   <arguments>": Use "file"   as your first argument to cleanse the rest of the command line of unicode, as if it were a windows filename
        MODE 3: "string <arguments>": Use "string" as your first argument to cleanse the rest of the command line of unicode, without restricting to only-valid-in-windows-fiklenames
        MODE 4: "test"              : to convert the internal testing string

    PROGRAMMATIC USAGE:
        import fixUnicodeFilenames
        a_string_without_unicode = fixUnicodeFilenames.convert_a_string  (original_stringval_with_unicode)
        filename_without_unicode = fixUnicodeFilenames.convert_a_filename(original_file_name_with_unicode,silent_if_unchanged=True)     #silent_if_unchanged=True suppresses output if nothing changes
         #silent=suppresses all output no matter what



    Uses Polyglot library to attempt a language-agnostic translation, which can easliy fail
    Then several internal custom mapping tables for phonetically romanizing characters & emojis
    Then several lingual libraries for romanizing individual characters for some "weirder alphabet" languages
    Then an emoji library for converting unconverted emojis


"""
























#pylint: disable=C0103,C0413,W0719,R1726
import os
os.system("")                                                               #necessary bugfix, believe it or not #GOAT but let's try taking it out to challenge ourselves and maybe speedup startup time
os.environ['PYTHAINLP_ZONEINFO_PACKAGE'] = 'tzdata'                         #necessary bugfix, believe it or not
import sys ; sys.setrecursionlimit(sys.getrecursionlimit() * 5)             #recursionlimit came up during EXE-build attempts
import msvcrt
import builtins
#import unidecode                                                           #pip install Unidecode==1.2.0 - for the right one - capitalizing the U (or not) is (or isn't) important. this package sucks.
import unicodedata
from unidecode import unidecode
from colorama import Fore, Back, Style, just_fix_windows_console
import fix_unicode_filenames_every_char as everychar
just_fix_windows_console()
#init()


############################ DEVELOPMENT CONFIGURATION ############################
DIE_ON_UNDECODEABLE_UNICODE_CHARACTER = True
DRY_RUN                               = False
###################################################################################


################################################ DEBUG ################################################
DEBUG_MOST_CHARS = False           #controls several debugs below
DEBUG_ALL_CHARS  = False           #controls several debugs below

DEBUG_ANNOUNCE_FILENAMES=True
DEBUG_MODE_ARGV=False
DEBUG_LANG_DETECT=False
DEBUG_POLYGLOT=False
DEBUG_CHAR                        = bool(False or DEBUG_ALL_CHARS or DEBUG_MOST_CHARS)
DEBUG_UNIDECODECHAR               = bool(False or DEBUG_ALL_CHARS or DEBUG_MOST_CHARS)
DEBUG_UNIDECODECHAR_TRANSLATECHAR = bool(False or DEBUG_ALL_CHARS)                      # super verbose
DEBUG_INTERNAL_TESTING=False
#######################################################################################################


############################ CONSTANTS ############################
INVALID_WINDOWS_FILENAME_CHARACTERS = r'<>:"/\|?*'
###################################################################

def last_minute_filename_cleanser(filename):
    global INVALID_WINDOWS_FILENAME_CHARACTERS
    if any(char in INVALID_WINDOWS_FILENAME_CHARACTERS for char in filename):
        filename = convert_a_filename(filename,silent_if_unchanged=False)   #TODO true
    filename = filename.lstrip('.-')  # Strip "." or "-" from the beginning of the filename
    return filename

###################################### TESTING ######################################
## CREATE A GOOD TESTING STRING:
#
#     This string includes:
#
#          ASCII text ("Hello, world!")
#          Chinese text ("√§¬Ω¬†√•¬•¬Ω√Ø¬º≈í√§¬∏‚Äì√ß‚Ä¢≈í√Ø¬º¬Å")
#          Japanese text ("√£¬Å‚Äú√£‚Äö‚Äú√£¬Å¬´√£¬Å¬°√£¬Å¬Ø√£‚Ç¨¬Å√§¬∏‚Äì√ß‚Ä¢≈í√Ø¬º¬Å")
#          Korean text ("√¨‚Ä¢ÀÜ√´‚Ä¶‚Ä¢√≠‚Ä¢Àú√¨‚Äû¬∏√¨≈°‚Äù, √¨‚Äû¬∏√™¬≥‚Äû!")
#          Russian text ("√ê≈∏√ë‚Ç¨√ê¬∏√ê¬≤√ê¬µ√ë‚Äö, √ê¬º√ê¬∏√ë‚Ç¨!")
#          Greek text ("√é≈°√é¬±√é¬ª√é¬∑√é¬º√é¬≠√è¬Å√é¬± √é¬∫√è≈í√è∆í√é¬º√é¬µ!")
#          Emoji ("√∞≈∏‚Äò‚Äπ√∞≈∏≈í¬ç")
#          Special symbols and numbers ("√¢¬Å¬µ√¢‚Äû‚Äú√Ç¬©√Ç¬Æ√Ç¬Ω√Ç¬º√Ç¬æ√¢‚Ä¶‚Äú√¢‚Ä¶‚Äù√¢‚Ä¶‚Ä∫√¢‚Ä¶≈ì√¢‚Ä¶¬ù√¢‚Ä¶≈æ√¢¬Å¬∞√Ç¬π√Ç¬≤√Ç¬≥√¢¬Å¬¥√¢¬Å¬µ√¢¬Å¬∂√¢¬Å¬∑√¢¬Å¬∏√¢¬Å¬π")
#          Mathematical Alphanumeric Symbols (√∞¬ù‚Äò¬®√∞¬ù‚Äô∆í√∞¬ù‚Äô‚Äû√∞¬ù‚Äô‚Ä¶√∞¬ù‚Äô‚Ä†√∞¬ù‚Äô‚Ä°√∞¬ù‚ÄôÀÜ√∞¬ù‚Äô‚Ä∞√∞¬ù‚Äô≈†√∞¬ù‚Äô‚Äπ√∞¬ù‚Äô≈í√∞¬ù‚Äô¬ç√∞¬ù‚Äô≈Ω√∞¬ù‚Äô¬è√∞¬ù‚Äô¬ê√∞¬ù‚Äô‚Äò√∞¬ù‚Äô‚Äô√∞¬ù‚Äô‚Äú√∞¬ù‚Äô‚Äù√∞¬ù‚Äô‚Ä¢√∞¬ù‚Äô‚Äì√∞¬ù‚Äô‚Äî√∞¬ù‚ÄôÀú√∞¬ù‚Äô‚Ñ¢√∞¬ù‚Äô≈°√∞¬ù‚Äô‚Ä∫ √∞¬ù‚Äò¬®√∞¬ù‚Äò¬©√∞¬ù‚Äò¬™√∞¬ù‚Äò¬´√∞¬ù‚Äò¬¨√∞¬ù‚Äò¬≠√∞¬ù‚Äò¬Æ√∞¬ù‚Äò¬Ø√∞¬ù‚Äò¬∞√∞¬ù‚Äò¬±√∞¬ù‚Äò¬≤√∞¬ù‚Äò¬≥√∞¬ù‚Äò¬¥√∞¬ù‚Äò¬µ√∞¬ù‚Äò¬∂√∞¬ù‚Äò¬∑√∞¬ù‚Äò¬∏√∞¬ù‚Äò¬π√∞¬ù‚Äò¬∫√∞¬ù‚Äò¬ª√∞¬ù‚Äò¬º√∞¬ù‚Äò¬Ω√∞¬ù‚Äò¬æ√∞¬ù‚Äò¬ø√∞¬ù‚Äô‚Ç¨√∞¬ù‚Äô¬Å)
#          Hebrew and Arabic scripts ("√ó¬ê√ñ¬∏√ó≈ì√ñ¬∂√ó¬£ √ò¬®√ô¬ê√ô≈†√ò¬™")
#          Various letters and symbols from different scripts (√á‚Äû√á‚Ä¶√á‚Ä†√á‚Ä°√áÀÜ√á‚Ä∞√á≈†√á‚Äπ√á≈í √°¬ª‚Äô√°¬ª¬£√°¬ª‚Äù√°¬ª‚Ñ¢ √°¬ª‚Äì√°¬ª‚Äî√°¬ªÀú√°¬ª‚Ñ¢ √°¬ª¬©√°¬ª¬§√°¬ª¬±√°¬ª¬¶√°¬ª¬≠ √°¬ª¬®√°¬ª¬Ø √°¬ª¬™√°¬ª¬≠√°¬ª¬¨√°¬ª¬´ √°¬ª¬Æ√°¬ª¬≠ √°¬ª¬∞√°¬ª¬±)

massive_testing_string_backup = "√Ç¬Ω√Ç¬º√Ç¬æ√¢‚Ä¶‚Äú√¢‚Ä¶‚Äù√¢‚Ä¶‚Ä∫√¢‚Ä¶≈ì√¢‚Ä¶¬ù√¢‚Ä¶≈æ"
massive_testing_string = """
Hello, world! √§¬Ω¬†√•¬•¬Ω√Ø¬º≈í√§¬∏‚Äì√ß‚Ä¢≈í√Ø¬º¬Å√£¬Å‚Äú√£‚Äö‚Äú√£¬Å¬´√£¬Å¬°√£¬Å¬Ø√£‚Ç¨¬Å√§¬∏‚Äì√ß‚Ä¢≈í√Ø¬º¬Å√¨‚Ä¢ÀÜ√´‚Ä¶‚Ä¢√≠‚Ä¢Àú√¨‚Äû¬∏√¨≈°‚Äù, √¨‚Äû¬∏√™¬≥‚Äû! √ê≈∏√ë‚Ç¨√ê¬∏√ê¬≤√ê¬µ√ë‚Äö, √ê¬º√ê¬∏√ë‚Ç¨! √é≈°√é¬±√é¬ª√é¬∑√é¬º√é¬≠√è¬Å√é¬± √é¬∫√è≈í√è∆í√é¬º√é¬µ!
HAND="√∞≈∏‚Äò‚Äπ",WORLD="√∞≈∏≈í¬ç" √¢¬Å¬µ√¢‚Äû‚Äú COPYRIGHT="√Ç¬©",RESTRICT="√Ç¬Æ"
√Ç¬Ω√Ç¬º√Ç¬æ√¢‚Ä¶‚Äú√¢‚Ä¶‚Äù√¢‚Ä¶‚Ä∫√¢‚Ä¶≈ì√¢‚Ä¶¬ù√¢‚Ä¶≈æ√¢¬Å¬∞√Ç¬π√Ç¬≤√Ç¬≥√¢¬Å¬¥√¢¬Å¬µ√¢¬Å¬∂√¢¬Å¬∑√¢¬Å¬∏√¢¬Å¬π
√∞¬ù‚Äò¬®√∞¬ù‚Äô∆í√∞¬ù‚Äô‚Äû√∞¬ù‚Äô‚Ä¶√∞¬ù‚Äô‚Ä†√∞¬ù‚Äô‚Ä°√∞¬ù‚ÄôÀÜ√∞¬ù‚Äô‚Ä∞√∞¬ù‚Äô≈†√∞¬ù‚Äô‚Äπ√∞¬ù‚Äô≈í√∞¬ù‚Äô¬ç√∞¬ù‚Äô≈Ω√∞¬ù‚Äô¬è√∞¬ù‚Äô¬ê√∞¬ù‚Äô‚Äò√∞¬ù‚Äô‚Äô√∞¬ù‚Äô‚Äú√∞¬ù‚Äô‚Äù√∞¬ù‚Äô‚Ä¢√∞¬ù‚Äô‚Äì√∞¬ù‚Äô‚Äî√∞¬ù‚ÄôÀú√∞¬ù‚Äô‚Ñ¢√∞¬ù‚Äô≈°√∞¬ù‚Äô‚Ä∫ √∞¬ù‚Äò¬®√∞¬ù‚Äò¬©√∞¬ù‚Äò¬™√∞¬ù‚Äò¬´√∞¬ù‚Äò¬¨√∞¬ù‚Äò¬≠√∞¬ù‚Äò¬Æ√∞¬ù‚Äò¬Ø√∞¬ù‚Äò¬∞√∞¬ù‚Äò¬±√∞¬ù‚Äò¬≤√∞¬ù‚Äò¬≥√∞¬ù‚Äò¬¥√∞¬ù‚Äò¬µ√∞¬ù‚Äò¬∂√∞¬ù‚Äò¬∑√∞¬ù‚Äò¬∏√∞¬ù‚Äò¬π√∞¬ù‚Äò¬∫√∞¬ù‚Äò¬ª√∞¬ù‚Äò¬º√∞¬ù‚Äò¬Ω√∞¬ù‚Äò¬æ√∞¬ù‚Äò¬ø√∞¬ù‚Äô‚Ç¨√∞¬ù‚Äô¬Å
√ó¬ê√ñ¬∏√ó≈ì√ñ¬∂√ó¬£ √ò¬®√ô¬ê√ô≈†√ò¬™ √á‚Äû√á‚Ä¶√á‚Ä†√á‚Ä°√áÀÜ√á‚Ä∞√á≈†√á‚Äπ√á≈í √°¬ª‚Äô√°¬ª¬£√°¬ª‚Äù√°¬ª‚Ñ¢ √°¬ª‚Äì√°¬ª‚Äî√°¬ªÀú√°¬ª‚Ñ¢ √°¬ª¬©√°¬ª¬§√°¬ª¬±√°¬ª¬¶√°¬ª¬≠ √°¬ª¬®√°¬ª¬Ø √°¬ª¬™√°¬ª¬≠√°¬ª¬¨√°¬ª¬´ √°¬ª¬Æ√°¬ª¬≠ √°¬ª¬∞√°¬ª¬±
"""


#####################################################################################




def print_error(*args, called_from_primt=False, **kwargs):                                                                                                             #pylint: disable=W0613
    if not called_from_primt: raise Exception("A print statement was used in the code. Use primt instead, because we want everything to go to our logfile")            #pylint: disable=W0719


def primt(*args, **kwargs):     #custom_print "prim print" function to print, prim and proper, to screen & logfile at the same time
    global LOGFILE

    new_args = []
    for arg in args:
        if isinstance(arg, str):
            new_arg = unidecode(arg)
            new_args.append(new_arg)
        else:
            new_args.append(arg)
    output = " ".join(map(str, new_args))

    original_print(output, **kwargs)                                    # Call the original print function that we saved before
    with open("fix-unicode-filenames.log", "a", encoding='utf-8') as log_file:
        #log_file.write(f"{strip_ansi_codes(output)}\n")
        log_file.write(f"{output}\n")


def convert_to_ascii_filename_chracters(filename,mode):
    """Translates a string (in our case, a filename) to its ASCII/roman equivalent

    (1) First, an amazing multi-language language-agnostic full translation library called polyglot is used
        to interpret the entire filename/string at a high ("smart") level to see if a language is detected,
        and then to make language-specific conversions to our ASCII/roman equivalent characters.

        But it throws an exception if a specific language is not detected, and it's also hard to install,
        so the entire thing is wrapped around an exception that just throws the original text if anything goes wrong.

        Also, polyglot will omit characters sometimes, so we do not want a null string

    (2) Then, each character is processed at a per-chracter level, checking its unicode range to see if it's a language,
        and then passing through either a language library or a phoenetic mapping table, to translate the chracters
        back to ASCII/roman.

    """
    global DEBUG, DEBUG_POLYGLOT
    string_romanized_with_polyglot = polyglot_language_agnostic_romanize(filename)
    if DEBUG_POLYGLOT:
        primt(f'DEBUG: string_romanized_with_polyglot({filename}) is "{string_romanized_with_polyglot}"')
    return ''.join(translate_character_with_language_libraries(char,mode,filename=filename) for char in string_romanized_with_polyglot)


#pylint: disable=C0415                                                                                  #don't nag me about lazy-loading the libraries, pylint!
def polyglot_language_agnostic_romanize(text):
    """Return translated text, but fail very gracefully and transparently if there are any exceptions"""
    global DEBUG, DEBUG_LANG_DETECT
    try:
        import logging
        if not DEBUG_LANG_DETECT: logging.getLogger('polyglot').setLevel(logging.ERROR)                             #Disable logging messages from Polyglot unless in debug mode
        from polyglot.detect import Detector
        from polyglot.transliteration import Transliterator
        detector = Detector(text)
        if DEBUG_LANG_DETECT: primt(f"* Detector: {str(detector)}")
        source_lang = detector.language.code
        transliterator = Transliterator(source_lang=source_lang, target_lang="en")
        return transliterator.transliterate(text)
    except Exception:                                                                                   #pylint: disable=W0718
        return text




def get_unicode_hex(character):
    if character == "": return "0"                                                                      #just fill in a dummy value
    return "\\u" + hex(ord(character))[2:].zfill(4)                                                     #thank you ChatGPT




def translate_one_or_more_chars_with_custom_character_mapping(chars, mode):                                                                                             #pylint: disable=R0912
    """
        Returns characters (after mapping), and done (boolean) which i used for flow control in the outer scope the first time it's called, but ignored the second time it's called
    """
    global DEBUG_UNIDECODECHAR_TRANSLATECHAR

    # Check valid mode
    valid_modes = ['string', 'file']
    if mode not in valid_modes:
        primt(f"{Fore.RED}FATAL TRANSLATE ERROR: translate_one_or_more_chars_with_custom_character_mapping called with invalid mode of {mode} which is not in {valid_modes}")
        sys.exit(666)

    translated_chars = []
    done = False

    code2 = ""                                      # unicode code without the \ before it
    for char in chars:                              # If it's not in our custom mapping, we basically pass through without doing anything
        code, code2 = "", ""
        if DEBUG_UNIDECODECHAR_TRANSLATECHAR:
            code  =     get_unicode_hex(char)
            code2 = "code " + str(get_unicode_hex(char)).replace("\\","")
            primt(f"\t{Fore.CYAN}translate_one_or_more_chars_with_custom_character_mapping(char={char},code={code},code2={code2})",end="")


        if char in unicode_to_ascii_custom_character_mapping:   #if it's not found now, it's really not found
            mapping = unicode_to_ascii_custom_character_mapping[char]
            if DEBUG_UNIDECODECHAR_TRANSLATECHAR: primt(f"{Fore.GREEN}    Found in mapping!",end="")
        else:
            if DEBUG_UNIDECODECHAR_TRANSLATECHAR: primt(f"{Fore.RED}Not found in mapping!",end="")
            code2 = "code " + str(get_unicode_hex(char)).replace("\\","")
            if code2 in unicode_to_ascii_custom_character_mapping:
                if DEBUG_UNIDECODECHAR_TRANSLATECHAR: primt(f"{Fore.GREEN}{Style.BRIGHT}Found by 2nd-attempt code lookup!{Style.NORMAL}",end="")
                mapping = unicode_to_ascii_custom_character_mapping[code2]
            else:
                if DEBUG_UNIDECODECHAR_TRANSLATECHAR: primt(f"{Style.BRIGHT}(Twice!)(code2={code2}){Style.NORMAL}",end="")
                translated_chars.append(char)
                continue

        #mapping = unicode_to_ascii_custom_character_mapping[char]
        if   len(mapping) == 0: raise Exception("FATAL ERROR: ZERO MAPPING LENGTH")
        if mode == "file" and len(mapping) > 1: mapping_number_to_use = 1
        else:                                   mapping_number_to_use = 0
        translated_chars.append(mapping[mapping_number_to_use])
        done = True                                                             # If any character is mapped, mark it as done

    return ''.join(translated_chars), done



def is_emoji_character(char):
    """Checks if a character is an emoji."""
    emoji_ranges = [
        ( '\u2600',  '\u26FF'),  # Miscellaneous Symbols
        ( '\u2700',  '\u27BF'),  # Dingbats
        ( '\uE000',  '\uF8FF'),  # Private Use Area
        ( '\uFE00',  '\uFE0F'),  # Variation Selectors
        ('\u1F000', '\u1F02B'),  # Mahjong Tiles, Domino Tiles, Playing Cards
        ('\u1F030', '\u1F093'),  # Enclosed Alphanumeric Supplement
        ('\u1F0A0', '\u1F0AE'),  # Playing cards
        ('\u1F100', '\u1F1FF'),  # Enclosed Alphanumeric Supplement
        ('\u1F200', '\u1F2FF'),  # Enclosed Ideographic Supplement
        ('\u1F1E6', '\u1F1FF'),  # Regional Indicator Symbols
        ('\u1F300', '\u1F5FF'),  # Miscellaneous Symbols and Pictographs
        ('\u1F600', '\u1F64F'),  # Emoticons
        ('\u1F680', '\u1F6FF'),  # Transport and Map Symbols
        ('\u1F700', '\u1F77F'),  # Alchemical Symbols
        ('\u1F780', '\u1F7FF'),  # Geometric Shapes Extended
        ('\u1F800', '\u1F8FF'),  # Supplemental Arrows-C
        ('\u1F900', '\u1F9FF'),  # Supplemental Symbols and Pictographs
        ('\u1FA00', '\u1FA6F'),  # Chess Symbols
        ('\u1FAB0', '\u1FAB6'),  # Face in Cloud, Spiral, Hole, Rock, Wood, Hut
        ('\u1FAC0', '\u1FAC2'),  # People Hugging, People with Bunny Ears, Person in Tuxedo
        ('\u1FAD0', '\u1FAD6'),  # Heart on Fire, Mending Heart, Face Exhaling, Face with Spiral Eyes, Face in Clouds
        ('\u1FA70', '\u1FAFF'),  # Symbols and Pictographs Extended-A
    ]
    for start, end in emoji_ranges:
        if start <= char <= end: return True
    return False
is_emoji = is_emoji_character

def is_unicode_character(char):
    """Checks if a character is a valid Unicode character."""
    unicode_range = ('\u0000', '\U0010FFFF')
    return unicode_range[0] <= char <= unicode_range[1]



def translate_character_with_language_libraries(char,mode,filename="not given"):                                                                #pylint: disable=R0912,R0915
    """Translates a single character to its ASCII/roman equivalent.

        Each character is processed individually, checking its unicode value.

        The value is checked to see if it in the range of seveal specific languages.

        For some languages, we use a language-specific proprietary library     to convert back to ASCII/roman characters.
        For some languages, we use a language-specific phoenetic mapping table to convert back to ASCII/roman characters.

        Note that the final step, unidecode.unicode, is a multi-lingual catch-all.

        For example, it is purported to remove accents over French/Spanish, vowels, & change Russian to phonetic equivalents

        LANGUAGE SUPPORT:

        Our list of addressed languages, even if only implicitly/partially addressed is, at the very least:

                Arabic, Bengali, Chinese, English, French, Hindi, Japanese, Korean, Spanish, Russian, Thai

        NEW LANGUAGES:

        We do not need to actually and every language in existence.
        We attempted to add the most common languages that have hard-to-romanize alphabets (usually non-"Western" languages)
        Common languages that have easy-to-romanize alphabets are likely covered by unidecode.unicode.

    """
    global DEBUG, DEBUG_CHAR, DEBUG_UNIDECODECHAR, DIE_ON_UNDECODEABLE_UNICODE_CHARACTER

    char_for_primt = char.encode('utf-16', 'surrogatepass').decode('utf-16','ignore')

    if DEBUG_CHAR:
        try:
            primt (f"- DEBUG: char is {Fore.YELLOW}{char}{Fore.WHITE}\tvalue {Fore.YELLOW}{get_unicode_hex(char)}{Fore.WHITE}{Style.NORMAL}",end="")
        except Exception:                                                                                   #pylint: disable=W0718
            primt (f"- DEBUG: char is {Fore.YELLOW}{char_for_primt}{Fore.WHITE}\tvalue {Fore.YELLOW}{get_unicode_hex(char)}{Fore.WHITE}{Style.NORMAL}",end="")


    # First we check our custom mapping, our highest priority. It is hand-created and thought out.
    char, done = translate_one_or_more_chars_with_custom_character_mapping(char,mode)
    if DEBUG_CHAR: primt (f" \t... custom mapping: {Fore.YELLOW}{char}{Fore.WHITE}\tdone={done:1}",end="")
    if done:
        if DEBUG_CHAR: primt("")
        return char

    # if a character is still untranslated, then we check our various lingual libraries and phoenetic mapping tables:
    is_emoji = False
    caught = False
    translate_return_value = ""
    if   '\u0600' <= char <= '\u06FF': caught,is_unicode=True,True; translate_return_value = translate_arabic___to_ascii(char) # if Arabic
    elif '\u0900' <= char <= '\u097F': caught,is_unicode=True,True; translate_return_value = translate_hindi____to_ascii(char) # if Hindi
    elif '\u0980' <= char <= '\u09FF': caught,is_unicode=True,True; translate_return_value = translate_bengali__to_ascii(char) # if Bengali
    elif '\u0E01' <= char <= '\u0E5B': caught,is_unicode=True,True; translate_return_value = translate_thai_____to_ascii(char) # if Thai
    elif '\u3040' <= char <= '\u30ff': caught,is_unicode=True,True; translate_return_value = translate_japanese_to_ascii(char) # if Japanese
    elif '\u4e00' <= char <= '\u9fff': caught,is_unicode=True,True; translate_return_value = translate_chinese__to_ascii(char) # if Chinese
    elif '\uac00' <= char <= '\ud7af': caught,is_unicode=True,True; translate_return_value = translate_korean___to_ascii(char) # if Korean
    elif is_emoji_character(char)  :                                                                                           # if Emoji
        demojified = translate_emoji_to_ascii(char)
        if demojified:
            caught, is_emoji = True, True
            translate_return_value = demojified
        else:
            caught, is_emoji = False, False
        if DEBUG_UNIDECODECHAR: primt(f" | is_emomji?={is_emoji_character(char):1} | caight?={caught} | {char} {Style.BRIGHT}de-{Style.NORMAL}emojied is '{Fore.YELLOW}{demojified}'{Fore.WHITE} | translate_return_value={translate_return_value}",end="")

    # if a character is even still untranlated, we need to use our catch-all code
    # this library purports to fix things all kinds of things like: Spanish n-with-tilde will become an N,
    # French c-with-a-hook will get hook removed, Russian is phonetically translated,
    # but we fear it may return nothing if it  doesn't have a great guess:
    is_unicode = caught
    if not caught:
        is_unicode = is_unicode_character(char)

    if not is_unicode:
        translate_return_value = char
    else:
        if caught: char = translate_return_value
        unidecodeChar = unidecode(char)
        if DEBUG_UNIDECODECHAR:
            if unidecodeChar == '':  style_adjustment = f"{Fore.RED}"
            else:                    style_adjustment = f"{Fore.WHITE}"
            primt(f" | emoji?={is_emoji:1} | unicode?={is_unicode:1} | {char}\t{style_adjustment}uni{Style.BRIGHT}de{style_adjustment}{Style.NORMAL}coded is '{Fore.YELLOW}{unidecodeChar}{style_adjustment}'{Fore.WHITE}",end="")
        if unidecodeChar == "":
            translate_return_value = char

            hex = get_unicode_hex(char)
            unicodedata_decode = get_name_from_hex(hex)

            if unicodedata_decode not in ["", char, translate_return_value]:           #assign new character if it's actually a new character
                translate_return_value = unicodedata_decode
            else:                                                                      #fairly unreachable code but comment out the if part and this can be a fun way to find un-manually-mapped characters to add more pleasant/customized mapping
                message = f"{Fore.RED}{Style.BRIGHT}\n!!! FATAL DECODE ERROR: COULD NOT DECODE UNICODE CHARACTER OF {char} (unicode hex={hex}) !!!\nFilename = {filename}\nPlease add to custom mapping table at the bottom of fixUnicodeFilenames.py\nYou may need to copy and paste this character into google to find out what it actually is:\n%EDITOR% {sys.argv[0]}{Fore.WHITE}{Style.NORMAL}"
                if DIE_ON_UNDECODEABLE_UNICODE_CHARACTER: raise Exception(message)
                primt(message)
            translate_return_value = "{" + translate_return_value + "}"
        else:
            translate_return_value = unidecodeChar

    if DEBUG_CHAR or DEBUG_UNIDECODECHAR: primt("")

    #If we are in file mode, we need to make one more pass because the previous code could have turned it into something bad due to a bug:
    #First we check our custom mapping, our highest priority. It is hand-created and thought out.
    #translate_return_value, _ = translate_one_or_more_chars_with_custom_character_mapping(translate_return_value,mode) #TODO evaluate whether it is safe to disable this now that we have internal 'tegrity checks for key values that would be invalid filenames
    return translate_return_value


import emoji                                                                                                    # emoji    library
import romkan                                                                                                   # Japanese library
from pypinyin                   import lazy_pinyin, Style as PypinyinStyle                                      # Chinese  library
from korean_romanizer.romanizer import Romanizer          as KoreanRomanizer                                    # Korean   library
from pythainlp.transliterate    import romanize           as ThaiRomanize                                       # Thai     library

def translate_thai_____to_ascii(text): return ThaiRomanize(text)                                                # Thai
def translate_japanese_to_ascii(char): return romkan.to_roma(char)                                              # Japanese
def translate_chinese__to_ascii(char): return ''.join(lazy_pinyin(char, style=PypinyinStyle.TONE3))             # Chinese
def translate_bengali__to_ascii(text): return ''.join(bengali_to_english_phonetic.get(c, '_') for c in text)    # Bengali  (no library used)
def translate_arabic___to_ascii(text): return ''.join( arabic_to_english_phonetic.get(c, '_') for c in text)    # Arabic   (no library used)
def translate_hindi____to_ascii(text): return ''.join(  hindi_to_english_phonetic.get(c, '_') for c in text)    # Hindi    (no library used)
def translate_korean___to_ascii(text):                                                                          # Korean
    try:    retval = KoreanRomanizer(text).romanize()
    except: retval = text
    return  retval
def translate_emoji_to_ascii(char):
    demojized = emoji.demojize(char)
    if demojized.startswith(':') and demojized.endswith(':'): return '{' + demojized[1:-1] + '}'
    return demojized


def get_name_from_hex(unicode_hex):
    unicode_hex = unicode_hex.replace('\\u', '')  # Remove the Unicode escape sequence part
    unicode_char = chr(int(unicode_hex, 16))  # Convert hex string to Unicode character
    try:
        return unicodedata.name(unicode_char)
    except ValueError:  # Raised when the character does not have a name
        return "[ERROR: get_name_from_hex fail]"



def ask_permission(old_name, new_name):
    """Asks the user for permission to rename a file."""
    primt(f"\n{Fore.YELLOW}{Style.BRIGHT}***** Rename:"                                                                   +
          f"\n{Fore.RED   }{Style.BRIGHT}From: {Style.NORMAL}{old_name}{Fore.CYAN}{Style.NORMAL}"                         +
          f"\n{Fore.GREEN }{Style.BRIGHT}  To: {Style.NORMAL}{new_name}{Fore.CYAN}{Style.NORMAL} "                        +
          f"\n{Fore.YELLOW}{Style.BRIGHT}***** Rename?"                                                                   +
          f" { Fore.BLUE  }{Style.BRIGHT}[{Fore.CYAN}Y{Fore.BLUE}/{Style.NORMAL}{Fore.CYAN}n{Style.BRIGHT}]{Style.NORMAL} ", end="")
    clear_keyboard_buffer()
    response = msvcrt.getch().decode().lower().strip()
    primt(Style.BRIGHT, end="")
    if response.lower() in ['y', 'yes', '']:
        primt(f"{Fore.GREEN}Yes!", end="")
        return True
    primt(f"{Fore.RED}No!", end="")
    return False

def clear_keyboard_buffer():
    while msvcrt.kbhit(): msvcrt.getch()


def rename_files_in_current_directory(mode="file",automatic_mode=False):                             #defaults to file mode
    """Renames all files in a directory, replacing unicode characters."""
    global DRY_RUN, DEBUG_ANNOUNCE_FILENAMES
    any_files_found_to_rename_at_all = False
    do_it_for_real = True
    automatic      = False
    DRY_RUN        = False
    permission     = False
    directory      = sys.argv[1] if len(sys.argv) > 1 else '.'                  #get all the files in the current dir...
    for filename in os.listdir(directory):
        filename_for_primt = filename.encode('utf-8','ignore')
        if DEBUG_ANNOUNCE_FILENAMES: primt(f"{Fore.CYAN}{Style.BRIGHT}* Processing file {filename}...{Style.NORMAL}{Fore.WHITE}")
        new_name = convert_to_ascii_filename_chracters(filename,mode)           #this is where all the magic happens

        if filename != new_name:
            any_files_found_to_rename_at_all = True
            if automatic_mode:
                automatic      = True
                do_it_for_real = True
                action_string  = "  Auto-Renamed"
            else:
                permission = ask_permission(filename, new_name)
                do_it_for_real = permission
                action_string  = "       Renamed" if permission is True else f"{Fore.RED}Did not rename"
            if DRY_RUN:
                do_it_for_real = False

            old_file = os.path.join(directory, filename)
            new_file = os.path.join(directory, new_name)

            if do_it_for_real: os.rename(old_file, last_minute_filename_cleanser(new_file))

            primt("\n")
            if automatic: primt(f"\t{Fore.YELLOW} Automatic Run: ")
            if DRY_RUN:   primt(f"\t{Fore.YELLOW}" +  "Dry Run: ")
            primt(f"{Fore.GREEN}{Style.NORMAL}\t{action_string}:\t{Fore.LIGHTBLACK_EX}{old_file} " +
                  f"{Fore.CYAN}\n\t\t    to:\t{Fore.GREEN}{new_file}{Style.NORMAL}\n\n\n")
    if not any_files_found_to_rename_at_all:
        primt(f"{Fore.RED}No files with unicode characters found.{Style.RESET_ALL}")


## Public calls:
def convert_a_string  (string_to_convert  ,silent_if_unchanged=False, silent=False): return just_convert_a_string(  string_to_convert,"string",silent_if_unchanged=silent_if_unchanged,silent=silent)
def convert_a_filename(filename_to_convert,silent_if_unchanged=False, silent=False): return just_convert_a_string(filename_to_convert,"file"  ,silent_if_unchanged=silent_if_unchanged,silent=silent)

def just_convert_a_string(string_to_convert,mode,silent_if_unchanged=False,silent=False):
    global DIE_ON_UNDECODEABLE_UNICODE_CHARACTER
    if __name__ != "__main__": DIE_ON_UNDECODEABLE_UNICODE_CHARACTER=False          #only die when being run, not when being imported

    if mode == "test":
        run_internal_tests()
        for temp_mode in ["file", "string"]:
            primt (f"\n\n{Fore.YELLOW}{Style.BRIGHT}* Testing in mode {temp_mode}:{Style.NORMAL}\n")
            primt ("Test result: " + just_convert_a_string(string_to_convert,temp_mode))
        return ":)"

    romanized_string  = convert_to_ascii_filename_chracters(string_to_convert,mode)     #...which we then fix the same way we would fix our filenames
    if silent or (silent_if_unchanged and string_to_convert == romanized_string):
        pass #don't primt
    else:
        primt(f"{Fore.RED}Old string: {string_to_convert}")
        primt(f"{Fore.GREEN}New string: {romanized_string }")
    return romanized_string


def run_internal_tests():
    primt (f"{Fore.GREEN}{Style.BRIGHT}\nRunning internal mapping table integrity test for valid filename characters...{Style.NORMAL}")
    internal_mapping_table_integrity_test_check_for_invalid_filename_chars()
    primt (f"{Fore.GREEN}{Style.BRIGHT}Passed!{Style.NORMAL}")

def internal_mapping_table_integrity_test_check_for_invalid_filename_chars():
    #NEW LANGUAGES might get added here
    global INVALID_WINDOWS_FILENAME_CHARACTERS, DEBUG_INTERNAL_TESTING
    global unicode_to_ascii_custom_character_mapping
    global hindi_to_english_phonetic, arabic_to_english_phonetic, bengali_to_english_phonetic
    dictionaries = {"hindi"   : hindi_to_english_phonetic                ,
                    "arabic"  : arabic_to_english_phonetic               ,
                    "bengali" : bengali_to_english_phonetic              ,
                    "custom"  : unicode_to_ascii_custom_character_mapping}
    anyFailed = False
    d = 0
    t = 0
    for dictionary_name, dictionary in dictionaries.items():
        d += 1
        primt(f"{Fore.GREEN}{Style.BRIGHT}- Testing dictionary #{d}: {dictionary_name}")
        e = 0
        for key, value in dictionary.items():
            e += 1
            t += 1
            stringValue = key
            fileValue   = ""
            if len(value) > 1: fileValue = value[1]
            else             : fileValue = value[0] if value else stringValue
            if DEBUG_INTERNAL_TESTING: primt(f"{Fore.GREEN}{Style.NORMAL}- Testing entry #{t}: Dict #{d}, entry#{e}: [key={key},value={value}] [strVal={stringValue},fileVal={fileValue}]")
            if fileValue != "":
                #DEBUG: if DEBUG_INTERNAL_TESTING: primt(f"\t- File value found: '{fileValue}'")
                if any(char in fileValue for char in INVALID_WINDOWS_FILENAME_CHARACTERS):
                    primt(f"\t{Fore.RED}{Style.BRIGHT}- stringValue={stringValue} in fileValue={Back.LIGHTBLACK_EX}{fileValue}{Back.BLACK} in dictionary d={d}, entry e={e}, contains invalid character! Cannot contain any character from INVALID_WINDOWS_FILENAME_CHARACTERS={Fore.YELLOW}{INVALID_WINDOWS_FILENAME_CHARACTERS}\n{Fore.YELLOW}{Style.NORMAL}This means you need to edit your code so that the first value in the value array is a valid windows filename. I.E. in our dictionary of Character:[translation1,translation2], the translation1 provided of '{fileValue}' has invalid windows filename characters in it (i.e. one of the following characters:{Fore.RED}{INVALID_WINDOWS_FILENAME_CHARACTERS}{Fore.YELLOW}) and must be changed in the source code!\n{Style.BRIGHT}Basically, copy and paste this: {Back.LIGHTBLACK_EX}{fileValue}{Back.BLACK} (the part with the weird grey background), search for that in the source code, and make it not include any of these red characters: {Fore.RED}{INVALID_WINDOWS_FILENAME_CHARACTERS}{Fore.YELLOW}\n{Fore.RED}\tkey='{key}',value='{value}'")  #pylint: disable=C0301
                    anyFailed = True
    if anyFailed: sys.exit(6666)






def get_testing_string():
    global massive_testing_string                               #a versatile string full of all kinds of characters used for testing
    testing_string = massive_testing_string
    #TODO programatically add values from our mapping tables to test them out
    return testing_string


def get_mode(always_use_automatic_mode=False):
    """Determines the current mode of the program based on the command-line arguments.

    Parameters:
    argv (list): List of command-line arguments.

    Returns:
    str: The current mode of the program, either 'filename' or 'string' or 'test'.
    """
    global DEBUG_MODE_ARGV
    AUTOMATIC_MODE = False

    return_value = 'unknown'
    if DEBUG_MODE_ARGV: primt (f"sys.argv is {sys.argv}")
    if len(sys.argv) > 1:                                                       #if first option is 'auto', set automatic_mode and pop that option off
        arg1 = sys.argv[1].lower()
        if arg1 in ['auto', 'automatic']:
            AUTOMATIC_MODE = True
            del sys.argv[1]

    if      os.getenv ('AUTOMATIC_UNICODE_CLEANING')  == "1":
        del os.environ['AUTOMATIC_UNICODE_CLEANING']                            #delete the environment variable so we only let this directive work once (we don't want to get stuck in automatic mode)     #might want to check if permissions actually allow this, though
        AUTOMATIC_MODE = True

    if always_use_automatic_mode: AUTOMATIC_MODE = True

    if len(sys.argv) > 1:
        arg1 = sys.argv[1].lower()
        if   arg1 in ['stringmode', 'string']: return_value = 'string'
        elif arg1 in ['filename'  , 'file'  ]: return_value = 'file'
        elif arg1 in ['testing'   , 'test'  ]:
            if len(sys.argv) > 2:
                primt (f'\n{Fore.RED}ERROR: Mode of {Style.BRIGHT}"test"{Style.NORMAL} cannot accept any other parameters as it uses an internal testing string. ')
                sys.exit(666)
            return_value = 'test'
        else:
            valid_modes = ["string", "file", "test"]
            primt (f'\n{Fore.RED}ERROR: Mode of {Style.BRIGHT}"{arg1}"{Style.NORMAL} is not a valid mode from the possible valid modes of: {valid_modes}. ')
            sys.exit(666)

    if DEBUG_MODE_ARGV: primt (f"{Fore.BLUE}* Running in {return_value} mode with arguments {sys.argv}.\n\tAUTOMATIC_MODE is {AUTOMATIC_MODE}")
    return return_value, AUTOMATIC_MODE



def main():
    mode_name, mode_is_automatic = get_mode(always_use_automatic_mode=False)

    if len(sys.argv) == 1:
        rename_files_in_current_directory(mode="file",automatic_mode=mode_is_automatic)       #MODE 1: Fix all files in the current folder, in filename mode
        sys.exit(0)
    elif mode_name == 'test':                                                                 #MODE 4: Prepare to translate internal testing string
        string_to_process = get_testing_string() + "\n\n\n TESTING STRING #2: \n\n\n" + everychar.ALMOST_EVERY_CHARACTER
    else:
        string_to_process = " ".join(sys.argv[2:])                                            #MODES 2 & 3: Prepare to translate our command-line string

    just_convert_a_string(string_to_process,mode_name)                                        #MODES 2 - 4: Run the proper translation

    if mode_name == 'test': primt(f"{Style.BRIGHT}{Fore.GREEN}\n...Seems like all tests passed if we got this far!")




########################################################################################################################################################################################
########################################################################################################################################################################################
########################################################################################################################################################################################
########################################################################################################################################################################################
########################################################################################################################################################################################
########################################################################################################################################################################################
########################################################################################################################################################################################
########################################################################################################################################################################################



arabic_to_english_phonetic = {
    'ÿß': 'a', 'ÿ®': 'b', 'ÿ™': 't', 'ÿ´': 'th', 'ÿ¨': 'j', 'ÿ≠': 'h', 'ÿÆ': 'kh', 'ÿØ': 'd', 'ÿ∞': 'dh', 'ÿ±': 'r', 'ÿ≤': 'z', 'ÿ≥': 's',
    'ÿ¥': 'sh', 'ÿµ': 's', 'ÿ∂': 'd', 'ÿ∑': 't', 'ÿ∏': 'z', 'ÿπ': 'a', 'ÿ∫': 'gh', 'ŸÅ': 'f', 'ŸÇ': 'q','ŸÉ': 'k', 'ŸÑ': 'l', 'ŸÖ': 'm',
    'ŸÜ': 'n', 'Ÿá': 'h', 'Ÿà': 'w', 'Ÿä': 'y', 'ÿ°': "'", 'ÿ©': 'h', 'Ÿâ': 'a', 'ÿ¶': 'a', 'ÿ§': 'o', 'Ÿé': 'a', 'Ÿê': 'i', 'Ÿè': 'u', 'Ÿ†': '0',
    'Ÿ°': '1', 'Ÿ¢': '2', 'Ÿ£': '3', 'Ÿ§': '4', 'Ÿ•': '5', 'Ÿ¶': '6', 'Ÿß': '7', 'Ÿ®': '8', 'Ÿ©': '9'
}
bengali_to_english_phonetic = {
    '‡¶Ö': 'o', '‡¶Ü': 'a', '‡¶á': 'i', '‡¶à': 'ee', '‡¶â': 'u', '‡¶ä': 'oo', '‡¶è': 'e', '‡¶ê': 'oi', '‡¶ì': 'o', '‡¶î': 'ou', '‡¶ï': 'k', '‡¶ñ': 'kh',
    '‡¶ó': 'g', '‡¶ò': 'gh', '‡¶ô': 'ng', '‡¶ö': 'ch', '‡¶õ': 'chh', '‡¶ú': 'j', '‡¶ù': 'jh', '‡¶û': 'n', '‡¶ü': 't', '‡¶†': 'th', '‡¶°': 'd', '‡¶¢': 'dh',
    '‡¶£': 'n', '‡¶§': 't', '‡¶•': 'th', '‡¶¶': 'd', '‡¶ß': 'dh', '‡¶®': 'n', '‡¶™': 'p', '‡¶´': 'ph', '‡¶¨': 'b', '‡¶≠': 'bh', '‡¶Æ': 'm', '‡¶Ø': 'y',
    '‡¶∞': 'r', '‡¶≤': 'l', '‡¶∂': 'sh', '‡¶∑': 'sh', '‡¶∏': 's', '‡¶π': 'h', '‡¶º': '', '‡¶æ': 'a', '‡¶ø': 'i', '‡ßÄ': 'ee', '‡ßÅ': 'u', '‡ßÇ': 'oo',
    '‡ßÉ': 'ri', '‡ßá': 'e', '‡ßà': 'oi', '‡ßã': 'o', '‡ßå': 'ou', '‡ßé': 't', '‡ß¶': '0', '‡ßß': '1', '‡ß®': '2', '‡ß©': '3', '‡ß™': '4', '‡ß´': '5',
    '‡ß¨': '6', '‡ß≠': '7', '‡ßÆ': '8', '‡ßØ': '9'
}
hindi_to_english_phonetic = {
    '‡§Ö': 'a', '‡§Ü': 'aa', '‡§á': 'i', '‡§à': 'ii', '‡§â': 'u', '‡§ä': 'uu', '‡§è': 'e', '‡§ê': 'ai', '‡§ì': 'o', '‡§î': 'au', '‡§ã': 'ri', '‡§ï': 'k',
    '‡§ñ': 'kh', '‡§ó': 'g', '‡§ò': 'gh', '‡§ô': 'ng', '‡§ö': 'ch', '‡§õ': 'chh', '‡§ú': 'j', '‡§ù': 'jh', '‡§û': 'n', '‡§ü': 't', '‡§†': 'th', '‡§°': 'd',
    '‡§¢': 'dh', '‡§£': 'n', '‡§§': 't', '‡§•': 'th', '‡§¶': 'd', '‡§ß': 'dh', '‡§®': 'n', '‡§™': 'p', '‡§´': 'ph', '‡§¨': 'b', '‡§≠': 'bh', '‡§Æ': 'm',
    '‡§Ø': 'y', '‡§∞': 'r', '‡§≤': 'l', '‡§µ': 'v', '‡§∂': 'sh', '‡§∑': 'sh', '‡§∏': 's', '‡§π': 'h', '‡§ï‡•ç‡§∑': 'ksh', '‡§§‡•ç‡§∞': 'tr', '‡§ú‡•ç‡§û': 'gy', '‡§∂‡•ç‡§∞': 'shr'
}




# Mapping of unicode symbols to ASCII equivalents that are valid for filenames
unicode_to_ascii_custom_character_mapping = {

    ## characters explicitly not valid in ascii filenames -- THESE NINE MUST BE LISTED FIRST IN THIS MAPPING FOR INTERNAL UNIT TESTING PURPOSES
    '*' :   ['*'  , 'x' ],  # ASCII asterisk
    '?' :   ['?'  , '_' ],  # ASCII question mark
    '|' :   ['|'  , '-' ],  # ASCII pipe
    ':' :   [':'  , '- '],  # ASCII     colon
    '/' :   ['/'  , '--'],  # ASCII     slash
    '\\':   ['\\/','--' ],  # ASCII backslash
    '<' :   ['<'  , '(' ],  # ASCII    less-than
    '>' :   ['>'  , ')' ],  # ASCII greater-than
    '"' :   ['"'  , "''" ], # ASCII quote          #converting to 2 apostrophes because of a theory of certain long filenames not being parseable if too many apostrophes and an odd number of apostrophes
    '^' :   ['-'],          # controversial, but this messes up Claire's personal TCC situation too much. If you want to allow carets in filenames, comment this line out.

    ## ones that look like the above but aren't, and are actually valid but we just don't like:
    'ÔºÅ':   '!' ,  # unicode exclamation mark
    'Ôºü':   ['?' , '_' ],  # unicode question mark
    'Ôºõ' :   [';'] ,  # unicode semicolon
    'Ôºå' :   [','] ,  # unicode comma
    '„ÄÇ' :   ['.'] ,  # unicode full stop
    '√Ø¬º≈∏':   ['?' , '_' ],  # unicode question mark
    '√Ø¬Ω≈ì':   ['|' , '-' ],  # unicode pipe
    '√Ø¬º≈°' :   [':' , '- '],  # unicode colon
    '√Ø¬º≈°' :   [':' , '-' ],  # unicode colon
    '√¢¬ß¬∏' :   ['/' , '--'],  # unicode slash             [the slash doesn't render right in EditPlus but it's HUUUGE]

    ## characters that are problematic with command line processors
    '%' :   ['%' , 'pct'],  # percent sign               [substitution only needed for filenames]        #TODO make this configurable with config deleting this key
    '`' :   ["'" , "'"],    # backtick                  [2 of these in a filename can makes parsers think there is bad quoting]

    ## charcters that other libraries will convert to invalid filenames if we don't handle that first
    '√Ç¬ø' :   ['?'  , '_'     ],  # ASCII question mark for spanish which a later library would convert to invalid "?" otherwise
    '√Ç¬Ω' :   ['1/2', 'Half ' ],  # ASCII 1/2 symbol


    # Emojis with ASCII equivalents: faces:
    "üò∞": [":'(", "TT"],   # anxious face with sweat
    "üòß": [":|", "TT"],    # anguished face
    "üò†": ["):<", "]-["],   # angry face
    "üò≤": [":O", "O_O"],    # astonished face
    "üòÅ": ["^_^", "{beaming face with smiley eyes}"],          # beaming face with smiling eyes
    "üòñ": [">.<", "{confounded face}"],    # confounded face
    "üòï": [":/", "{confused face}"],    # confused face
    "üò¢": [")':", "{crying face}"],   # crying face
    "üò≠": [")':", "TT"],   # loudly crying face
    "üòì": ["^^;", "^^'"],   # downcast face with sweat
    "üòà": [">;)", "{devil smiling}"],   # devil smiling
    "üòû": ["):", "]-["],    # disappointed face
    "üòë": ["-_-"],          # expressionless face
    "üòÆ": [":o", "O_O"],    # face with open mouth
    "üò§": [">:(", "]-["],   # face with steam from nose
    "üò®": [":o", "O_O"],    # fearful face
    "üò≥": [":$", "O_O"],    # flushed face
    "üò¶": ["):", "]-["],    # frowning face with open mouth
    "üò¨": ["D:", "D-"],     # grimacing face
    "üòÄ": [":)", "=)"],     # grinning face
    "üòÉ": [":D", "=D"],     # grinning face with big eyes
    "üòÑ": ["XD"],           # grinning face with smiling eyes
    "üòÖ": ["^_^'","{grinning face with sweat}"],         # grinning face with sweat
    "üòÜ": ["X'D", "XD"],    # grinning squinting face
    "üòá": ["O:)", "O)"],   # halo face
    "üòØ": [":o", "O_O"],    # hushed face
    "üòó": [":*", "{kissing face}"],    # kissing face
    "üòò": [":*", "{blowing a kiss}"],    # kiss blowing face
    "üòô": [":*", "{kiss with smiling eyes}"],    # kissing face with smiling eyes
    "üòö": ["XOXO"],         # kissing face with closed eyes
    "üò≠": [")':", "{loudly crying face}"],   # loudly crying face
    "üòî": ["):", "{pensive face}"],    # pensive face
    "üò£": [">.<", "{persevering face}"],    # persevering face
    "üò°": [">_<", "{pouting face}"],   # pouting face
    "üò•": [")':", "{sad but relieved face}"],   # sad but relieved face
    "üò±": [":O", "O_O"],    # screaming in fear
    "üò™": ["X|", "-_-"],    # sleepy face
    "üôÇ": [":)", "=)"],     # slightly smiling face
    "üòç": ["<3_<3", "{smiling face with heart eyes}D"],  # smiling face with heart eyes
    "üòé": ["B-)", "B)"],    # smiling face with sunglasses




    # Emojis with ASCII equivalents: hearts
    "‚ù§Ô∏è":   ["<3", "(3"],     # {heart}
    'üíî':  ['</3', "(3_3"],     # Broken Heart
    'üíï': ['<3<3', "(3(3"],     # Two Hearts
    'üíñ':   ['<3', "(3"],     # Sparkling Heart
    "üíó":  ["<3<3", "(3(3"],    # {growing heart}
    "üíô":   ["<3", "(3"],     # {blue heart}
    "üíö":   ["<3", "(3"],     # {green heart}
    "üíõ":   ["<3", "(3"],     # {yellow heart}
    "üíú":   ["<3", "(3"],     # {purple heart}
    "üñ§":   ["<3", "(3"],     # {black heart}
    "üíù":   ["<3", "(3"],     # {heart with ribbon}
    "üíû":  ["<3<3", "(3(3"],    # {revolving hearts}
    "üíü":   ["<3", "(3"],     # {heart decoration}
    "üíå":   ["<3", "(3"],     # {love letter}
    "‚ù§Ô∏è‚Äçü©π": ["<3:)", "(3_)"],    # {mending heart}
    "‚ù£Ô∏è":   ["<3!", "(3!"],    # {heart exclamation}
    "‚ù§Ô∏è‚Äçüî•": ["<3", "(3"],     # {heart on fire}


    # Emojis with ASCII equivalents: faces:
    "üòù": ["XP", "XP"],       # {squinting face with tongue}
    "üò§": [">:(", "{face with steam from nose}"],      # {steam from nose}
    "üòõ": [":p", "{sticking out tongue}"],       # {sticking out tongue}
    "üòä": [":)", "=)"],       # {smiling face with smiling_eyes}
    "üòè": [";)", "{smirking}"],       # {smirking_face}
    "üòì": ["^_^;", "{downcast face with sweat},"],     # {sweat face aka downcast_face_with_sweat}
    "üòÇ": ["XD", "XD"],       # {tears of joy face}
    "üò´": [":/", "{tired face}"],       # {tired_face}
    "üòí": [":/", "{unamused face}"],       # {unamused_face}
    "üò©": ["):", "{weary face}"],       # {weary_face}
    "üòú": [";p", "{winking face with tongue}"],       # {winking face with tongue}
    "üòü": ["/:", "{worried face}"],       # {worried_face}
    "üòâ": [";)", ";)"],       # {winking_face} (with tongue)



    '√Ø¬º¬Å':    ['!'],   # unicode exclamation mark
    '√Ø¬º‚Ä∫' :    [';'],   # unicode semicolon
    '√Ø¬º≈í' :    [','],   # unicode comma
    '√£‚Ç¨‚Äö' :    ['.'],   # unicode period

    '√Ø¬ºÀÜ ':    ['('],   #   unicode open  paren
    '√Ø¬º‚Ä∞' :    [')'],   #   unicode close paren
    '√¢¬Å¬Ω' :    ['('],   #   unicode open  paren
    '√¢¬Å¬æ' :    [')'],   #   unicode close paren
    '√¢‚Äö¬ç'	:    ['('],   #   Subscript Left  Parenthesis
    '√¢‚Äö≈Ω'	:    [')'],   #   Subscript Right Parenthesis
    '√Ø¬π‚Ñ¢' :    ['('],   #  unicode open  paren
    '√Ø¬π≈°' :    [')'],   #  unicode close paren

    '√Ø¬º¬Ω' :    [']'],   #   unicode right bracket
    '√£‚Ç¨¬ê' :    ['['],   #   unicode left  bracket
    '√£‚Ç¨‚Äò' :    [']'],   #   unicode right bracket
    '√£‚Ç¨‚Äù' :    ['['],   #   unicode left  bracket
    '√Ø¬º¬ª' :    ['['],   #   unicode left  bracket
    '√£‚Ç¨‚Ä¢' :    [']'],   #   unicode right bracket
    '√Ø¬π¬ù':     ['['],  #   unicode left  bracket
    '√Ø¬π≈æ':     [']'],  #   unicode right bracket

    '√Ø¬Ω‚Ä∫' :    ['{'],   #   unicode left  brace
    '√Ø¬Ω¬ù' :    ['}'],   #   unicode right brace
    '√Ø¬π‚Ä∫':     ['{'],  #   unicode left  brace
    '√Ø¬π≈ì':     ['}'],  #   unicode right brace

    '√£‚Ç¨ÀÜ' :    ['<','['],   #  unicode    less-than
    '√£‚Ç¨‚Ä∞' :    ['>',']'],   #  unicode greater-than
    '√¢≈í¬©' :    ['<','['],   #   unicode    less-than
    '√¢≈í¬™' :    ['>',']'],   #   unicode greater-than
    '„Äà' :      ['<','['],   # '<',   #  unicode    less-than
    '„Äâ' :      ['>',']'],   # '>',   #  unicode greater-than
    '‚å©' :       ['<','['],   #'<',   #   unicode    less-than
    '‚å™' :       ['>',']'],   #'>',   #   unicode greater-than

    '√Ø¬Ω≈∏' :   ['(('],   #   unicode double left  paren
    '√Ø¬Ω¬†' :   ['))'],   #   unicode double right paren
    '√£‚Ç¨‚Äì':   ['[('],   #   unicode left   combo-paren/bracket
    '√£‚Ç¨‚Äî':   [')]'],   #   unicode right  combo-paren/bracket
    '√£‚Ç¨≈°':   ['[['],   #   unicode double left  bracket
    '√£‚Ç¨‚Ä∫':   [']]'],   #   unicode double right bracket
    '√£‚Ç¨Àú':   ['[['],   #   unicode double left  bracket
    '√£‚Ç¨‚Ñ¢':   [']]'],   #   unicode double right bracket
    '√£‚Ç¨≈†' :   ['<<','[['],   #   unicode double     less-than
    '√£‚Ç¨‚Äπ' :   ['>>',']]'],   #   unicode double  greater-than
    '√°≈°‚Ä∫' :   [ '>-',']-'],  #
    '√°≈°≈ì' :   [ '-<','-['],  #

    '√™¬ß¬Å':  ['(('],   #javanese left rereggan
    '√™¬ß‚Äö':  ['))'],   #javanese right rereggan
    '√£‚Ç¨≈Ω' :   ['['] ,   #\
    '√£‚Ç¨≈í' :   ['['] ,   # \
    '√Ø¬Ω¬¢' :   ['['] ,   #  \____ used to think of these as "F" and "J" but after seeing them in anime videos a lot, realized they were brackets
    '√£‚Ç¨¬è' :   [']'] ,   #  /
    '√£‚Ç¨¬ç' :   [']'] ,   # /
    '√Ø¬Ω¬£' :   [']'] ,   #/


    '√è‚Ç¨' :   ['Pi'],   #decent

    '√¢¬Å¬±'	:   ['^i'], 	#Superscript Latin Small Letter I
    '√¢¬Å¬ø'	:   ['^n'], 	#Superscript Latin Small Letter N
    '√¢¬Å¬∞'	:   ['^o'], 	#Superscript Zero
    '√Ç¬π' :   ['^1'],   #Superscript 2 which is upper-ASCII and not actually unicode
    '√Ç¬≤' :   ['^2'],   #Superscript 2 which is upper-ASCII and not actually unicode
    '√¢¬Å¬¥'	:   ['^4'], 	#Superscript Four
    '√¢¬Å¬µ'	:   ['^5'], 	#Superscript Five
    '√¢¬Å¬∂'	:   ['^6'], 	#Superscript Six
    '√¢¬Å¬∑'	:   ['^7'], 	#Superscript Seven
    '√¢¬Å¬∏'	:   ['^8'], 	#Superscript Eight
    '√¢¬Å¬π'	:   ['^9'], 	#Superscript Nine
    '√¢¬Å¬∫'	:   [ '+'], 	#Superscript Plus Sign
    '√¢¬Å¬ª'	:   [ '-'], 	#Superscript Minus
    '√¢¬Å¬º'	:   [ '='], 	#Superscript Equals Sign
    '√¢‚Äö‚Ç¨'	:  ['(0)'], 	#Subscript Zero
    '√¢‚Äö¬Å'	:  ['(1)'], 	#Subscript One
    '√¢‚Äö‚Äö'	:  ['(2)'], 	#Subscript Two
    '√¢‚Äö∆í'	:  ['(3)'], 	#Subscript Three
    '√¢‚Äö‚Äû'	:  ['(4)'], 	#Subscript Four
    '√¢‚Äö‚Ä¶'	:  ['(5)'], 	#Subscript Five
    '√¢‚Äö‚Ä†'	:  ['(6)'], 	#Subscript Six
    '√¢‚Äö‚Ä°'	:  ['(7)'], 	#Subscript Seven
    '√¢‚ÄöÀÜ'	:  ['(8)'], 	#Subscript Eight
    '√¢‚Äö‚Ä∞'	:  ['(9)'], 	#Subscript Nine
    '√¢‚Äö≈†'	:  ['(+)'], 	#Subscript Plus Sign
    '√¢‚Äö‚Äπ'	:  ['(-)'], 	#Subscript Minus
    '√¢‚Äö≈í'	:  ['(=)'], 	#Subscript Equals Sign
    '√¢‚Äö‚Äù'	:['(schwa)'], #Latin Subscript Small Letter Schwa
    '√¢‚Äö¬ê'	:   ['(a)'], 	#Latin Subscript Small Letter A
    '√¢‚Äö‚Äò'	:   ['(e)'],  #Latin Subscript Small Letter E
    '√¢‚Äö‚Äô'	:   ['(o)'], 	#Latin Subscript Small Letter O
    '√¢‚Äö‚Äú'	:   ['(x)'], 	#Latin Subscript Small Letter X
    '√¢‚Äö‚Ä¢'	:   ['(h)'], 	#Latin Subscript Small Letter H     [doesn't render in EditPlus right so i'm not positive this is it]
    '√¢‚Äö‚Äì'	:   ['(k)'], 	#Latin Subscript Small Letter K     [doesn't render in EditPlus right so i'm not positive this is it]
    '√¢‚Äö‚Äî'	:   ['(l)'], 	#Latin Subscript Small Letter L     [doesn't render in EditPlus right so i'm not positive this is it]
    '√¢‚ÄöÀú'	:   ['(m)'], 	#Latin Subscript Small Letter M     [doesn't render in EditPlus right so i'm not positive this is it]
    '√¢‚Äö‚Ñ¢'	:   ['(n)'], 	#Latin Subscript Small Letter N     [doesn't render in EditPlus right so i'm not positive this is it]
    '√¢‚Äö≈°'	:   ['(p)'], 	#Latin Subscript Small Letter P     [doesn't render in EditPlus right so i'm not positive this is it]
    '√¢‚Äö‚Ä∫'	:   ['(s)'], 	#Latin Subscript Small Letter S     [doesn't render in EditPlus right so i'm not positive this is it]
    '√¢‚Äö≈ì'	:   ['(t)'], 	#Latin Subscript Small Letter T     [doesn't render in EditPlus right so i'm not positive this is it]


    '√†¬º¬º √†¬º¬Ω':  ['/\\','^'] ,   #a fairly good approximation

    '√¢ÀÜ≈æ' :['[Inf]'],   #tempted to make "8", but that would lose too much meaning


    '√¢ÀÜ‚Äò' :      ['Sum='],   #quite the stretch
    '√¢ÀÜ¬´' : ['Integral='],   #quite the stretch

    '√†¬º¬∫':    ['@:','@@'],  #a huge stretch, this barely even looks like that
    '√†¬º¬ª':    [':@','@@'],  #a huge stretch, this barely even looks like that


    'ÔΩü' :   '((',   #   unicode double left  paren
    'ÔΩ†' :   '))',   #   unicode double right paren
    '„Äñ':   '[(',   #   unicode left   combo-paren/bracket
    '„Äó':   ')]',   #   unicode right  combo-paren/bracket
    '„Äö':   '[[',   #   unicode double left  bracket
    '„Äõ':   ']]',   #   unicode double right bracket
    '„Äò':   '[[',   #   unicode double left  bracket
    '„Äô':   ']]',   #   unicode double right bracket
    '„Ää' :   ['<<','[['],   #   unicode double     less-than
    '„Äã' :   ['>>',']]'],   #   unicode double  greater-than
    '·öõ' :   ['>-',')-'],
    '·öú' :   ['-<','-('],

    'œÄ' :   'Pi',   #decent

    '‚Å±'	:   '^i', 	#Superscript Latin Small Letter I
    '‚Åø' :   '^n',   #Superscript n which is upper-ASCII and not actually unicode \____ might be the same chracter really
    '‚Åø'	:   '^n', 	#Superscript Latin Small Letter N                            /
    '‚Å∞'	:   '^o', 	#Superscript Zero
    '¬≤' :   '^2',   #Superscript 2 which is upper-ASCII and not actually unicode
    '‚Å¥'	:   '^4', 	#Superscript Four
    '‚Åµ'	:   '^5', 	#Superscript Five
    '‚Å∂'	:   '^6', 	#Superscript Six
    '‚Å∑'	:   '^7', 	#Superscript Seven
    '‚Å∏'	:   '^8', 	#Superscript Eight
    '‚Åπ'	:   '^9', 	#Superscript Nine
    '‚Å∫'	:    '+', 	#Superscript Plus Sign
    '‚Åª'	:    '-', 	#Superscript Minus
    '‚Åº'	:    '=', 	#Superscript Equals Sign
    '‚ÅΩ'	:    '(', 	#Superscript Left Parenthesis
    '‚Åæ'	:    ')', 	#Superscript Right Parenthesis
    '‚ÇÄ'	:  '(0)', 	#Subscript Zero
    '‚ÇÅ'	:  '(1)', 	#Subscript One
    '‚ÇÇ'	:  '(2)', 	#Subscript Two
    '‚ÇÉ'	:  '(3)', 	#Subscript Three
    '‚ÇÑ'	:  '(4)', 	#Subscript Four
    '‚ÇÖ'	:  '(5)', 	#Subscript Five
    '‚ÇÜ'	:  '(6)', 	#Subscript Six
    '‚Çá'	:  '(7)', 	#Subscript Seven
    '‚Çà'	:  '(8)', 	#Subscript Eight
    '‚Çâ'	:  '(9)', 	#Subscript Nine
    '‚Çä'	:  '(+)', 	#Subscript Plus Sign
    '‚Çã'	:  '(-)', 	#Subscript Minus
    '‚Çå'	:  '(=)', 	#Subscript Equals Sign
    '‚Çî'	:'(schwa)', #Latin Subscript Small Letter Schwa
    '‚Çê'	:   '(a)', 	#Latin Subscript Small Letter A
    '‚Çë'	:   '(e)',  #Latin Subscript Small Letter E
    '‚Çí'	:   '(o)', 	#Latin Subscript Small Letter O
    '‚Çì'	:   '(x)', 	#Latin Subscript Small Letter X
    '‚Çï'	:   '(h)', 	#Latin Subscript Small Letter H     [doesn't render in EditPlus right so i'm not positive this is it]
    '‚Çñ'	:   '(k)', 	#Latin Subscript Small Letter K     [doesn't render in EditPlus right so i'm not positive this is it]
    '‚Çó'	:   '(l)', 	#Latin Subscript Small Letter L     [doesn't render in EditPlus right so i'm not positive this is it]
    '‚Çò'	:   '(m)', 	#Latin Subscript Small Letter M     [doesn't render in EditPlus right so i'm not positive this is it]
    '‚Çô'	:   '(n)', 	#Latin Subscript Small Letter N     [doesn't render in EditPlus right so i'm not positive this is it]
    '‚Çö'	:   '(p)', 	#Latin Subscript Small Letter P     [doesn't render in EditPlus right so i'm not positive this is it]
    '‚Çõ'	:   '(s)', 	#Latin Subscript Small Letter S     [doesn't render in EditPlus right so i'm not positive this is it]
    '‚Çú'	:   '(t)', 	#Latin Subscript Small Letter T     [doesn't render in EditPlus right so i'm not positive this is it]


    '‡ºº ‡ºΩ':  ['/\\','{upside down v thingy}'] ,   #a fairly good approximation until you need valid filename chars

    '‚àû' :'[Inf]',   #tempted to make "8", but that would lose too much meaning

    '„Äé' :   'F' ,   # this is a stretch
    '„Äå' :   'F' ,   # this is a stretch
    'ÔΩ¢' :   'F' ,   # this is a stretch
    '„Äè' :   'J' ,   # this is a stretch, it's almost more like an L but backwards
    '„Äç' :   'J' ,   # this is a stretch, it's almost more like an L but backwards
    'ÔΩ£' :   'J' ,   # this is a stretch, it's almost more like an L but backwards

    '‚àë' :   'E=',   #quite the stretch, maybe "sigma" would be better
    '‚à´' :   'S=',   #quite the stretch, maybe "sum"   would be better

    #let's just take these out and let them be processed normally
    #'‡º∫':    ['@:'],  #a huge stretch, this barely even looks like that
    #'‡ºª':    [':@'],  #a huge stretch, this barely even looks like that


    # Emojis with ASCII equivalents: faces:
    "√∞≈∏Àú¬∞": ['(@_@)'],   # anxious face with sweat
    "√∞≈∏Àú¬ß": [":|", "D8"],    # anguished face
    "√∞≈∏Àú¬†": ["):<", "x_x"],   # angry face
    "√∞≈∏Àú¬≤": [":O", "O_O"],    # astonished face
    "√∞≈∏Àú¬Å": ["^_^","{beaming face with smiling eyes}"],          # beaming face with smiling eyes
    "√∞≈∏Àú‚Äì": ["o_O"],          # confounded face
    "√∞≈∏Àú‚Ä¢": ["o_O"],          # confused face
    "√∞≈∏Àú¬¢": [")':", ";_;"],   # crying face
    "√∞≈∏Àú¬≠": [")':", ";_;"],   # loudly crying face
    "√∞≈∏Àú‚Äú": ['^._.^;'],       # downcast face with sweat
    "√∞≈∏ÀúÀÜ": [">;)", "XD"],   # devil smiling
    "√∞≈∏Àú≈æ": ["):", ")8"],    # disappointed face
    "√∞≈∏Àú‚Äò": ["-_-"],          # expressionless face
    "√∞≈∏Àú¬Æ": [":o", "O_O"],    # face with open mouth
    "√∞≈∏Àú¬§": [">:(", "8("],   # face with steam from nose
    "√∞≈∏Àú¬®": [":o", "8o"],    # fearful face
    "√∞≈∏Àú¬≥": [":$", "O_O"],    # flushed face
    "√∞≈∏Àú¬¶": ["):", ")8"],    # frowning face with open mouth
    "√∞≈∏Àú¬¨": ["D:", "D-"],     # grimacing face
    "√∞≈∏Àú‚Ç¨": [":)", "=)"],     # grinning face
    "√∞≈∏Àú∆í": [":D", "=D"],     # grinning face with big eyes
    "√∞≈∏Àú‚Äû": ["XD"],           # grinning face with smiling eyes
    "√∞≈∏Àú‚Ä¶": ["^_^'","{grinning face with sweat}"],         # grinning face with sweat
    "√∞≈∏Àú‚Ä†": ["X'D", "X'D"],   # grinning squinting face
    "√∞≈∏Àú‚Ä°": ["O:)", "O8)"],   # halo face
    "√∞≈∏Àú¬Ø": [":o", "8o"],    # hushed face
    "√∞≈∏Àú‚Äî": [":*", "xoxo"],    # kissing face
    "√∞≈∏ÀúÀú": [":*", "xoxo"],    # kiss blowing face
    "√∞≈∏Àú‚Ñ¢": [":*", "8)xoxo"],    # kissing face with smiling eyes
    "√∞≈∏Àú≈°": ["XOXO"],         # kissing face with closed eyes
    "√∞≈∏Àú‚Äù": ["):", ")8"],    # pensive face
    "√∞≈∏Àú¬£": [">.<", "{persevering face}"],    # persevering face
    "√∞≈∏Àú¬°": ["):", ")8"],   # pouting face
    "√∞≈∏Àú¬•": [")':", ")8"],   # sad but relieved face
    "√∞≈∏Àú¬±": [":O", "O_O"],    # screaming in fear
    "√∞≈∏Àú¬™": ["X|", "zzz"],    # sleepy face
    "√∞≈∏‚Ñ¢‚Äö": [":)", "=)"],     # slightly smiling face
    "√∞≈∏Àú¬ç": ["<3_<3", "{smiling face with heat eyes}"],  # smiling face with heart eyes
    "√∞≈∏Àú≈Ω": ["B-)", "B)"],    # smiling face with sunglasses
    "√∞≈∏Àú¬ù": ["X'P", "X'P"],       # {squinting face with tongue}
    "√∞≈∏Àú‚Ä∫": [":p", "8p"],       # {sticking out tongue}
    "√∞≈∏Àú≈†": [":)", "=)"],       # {smiling face with smiling_eyes}
    "√∞≈∏Àú¬è": [";)", "^)"],       # {smirking_face}
    "√∞≈∏Àú‚Äö": ["XD", "XD"],       # {tears of joy face}
    #"√Ø¬ø¬Ω": [":/", "T_T"],       # {tired_face}
    "√∞≈∏Àú¬´": ["{tired face}"  ,],
    "√∞≈∏Àú‚Äô": [":/", "-_-"],       # {unamused_face}
    "√∞≈∏Àú¬©": ["):", "-_-"],       # {weary_face}
    "√∞≈∏Àú≈ì": [";p", ";p"],       # {winking face with tongue}
    "√∞≈∏Àú≈∏": [":/", "=O"],       # {worried_face}
    "√∞≈∏Àú‚Ä∞": [";p"],            # {winking_face} (with tongue)
    "√∞≈∏¬§¬≠": ["{face with hand over mouth}",],

    # Emojis with ascii equivalents: hearts
    "√∞≈∏‚ÄôÀú":  ["--<3-->","{heart with arrow}"],    # {heart with an arrow}
    "√¢‚Ñ¢¬°":   ["<3", "(3"],     # {heart}
    "√∞≈∏¬§¬ç":   ["<3", "(3"],     # {heart}
    "√¢¬ù¬§√Ø¬∏¬è":   ["<3", "(3"],     # {heart}
    '√∞≈∏‚Äô‚Äù':  ['</3', "(3_3"],     # Broken Heart
    '√∞≈∏‚Äô‚Ä¢': ['<3<3', "(3(3"],     # Two Hearts
    '√∞≈∏‚Äô‚Äì':   ['<3', "(3"],     # Sparkling Heart
    "√∞≈∏‚Äô‚Äî":  ["<3<3", "(3(3"],    # {growing heart}
    "√∞≈∏‚Äì¬§":   ["<3", "(3"],     # {black heart}
    "√∞≈∏‚Äô‚Ä∫":   ["<3", "(3"],     # {yellow heart}
    "√∞≈∏¬ß¬°":   ["<3", "(3"],     # {orange heart}
    "√∞≈∏‚Äô≈°":   ["<3", "(3"],     # {green heart}
    "√∞≈∏‚Äô‚Ñ¢":   ["<3", "(3"],     # {blue heart}
    "√∞≈∏‚Äô≈ì":   ["<3", "(3"],     # {purple heart}
    "√∞≈∏‚Äô¬ù":   ["<3", "(3"],     # {heart with ribbon}
    "√∞≈∏‚Äô≈æ":  ["<3<3", "(3(3"],    # {revolving hearts}
    "√∞≈∏‚Äô≈∏":   ["<3", "(3"],     # {heart decoration}
    "√∞≈∏‚Äô≈í":   ["<3", "(3"],     # {love letter}
    "√¢¬ù¬§√Ø¬∏¬è√¢‚Ç¨¬ç√∞≈∏¬©¬π": ["<3:)", "(3_)"],    # {mending heart}
    "√¢¬ù¬£√Ø¬∏¬è":   ["<3!", "(3!"],    # {heart exclamation}
    "√¢¬ù¬§√Ø¬∏¬è√¢‚Ç¨¬ç√∞≈∏‚Äù¬•": ["<3", "(3"],     # {heart on fire}


    # Emojis with descriptions: faces & human stuff:
    "√∞≈∏Àú≈í"   :   ["{phew!}"       ,],  # {relieved_face}
    "√∞≈∏‚Äò‚Äπ"   :   ["{waving hand}" ,],
    '√∞≈∏≈Ω‚Ä¶'   : ['{SANTA}',],       # emoji: Santa Claus
    '√∞≈∏‚Äô∆í': ['{DANCER}',],      # emoji: Woman Dancing
    '√∞≈∏‚Äô‚Ç¨': ['{SKULL}',],       # emoji: Skull
    '√∞≈∏‚Äô¬©': ['{POOP}',],        # emoji: Pile of Poo
    '√∞≈∏¬•¬∞': ['{feeling-loved face}',],
    '√∞≈∏¬§‚Äò': ['{money face}',],

    # Emojis with descriptions: small objects
    "√¢≈í≈°"   :   ["{watch}"       ,],
    "√∞≈∏¬ç≈Ω"   :   ["{red apple}"   ,],
    '√∞≈∏¬ç‚Ä∞'   :   ['{WATERMELON}'  ,],  # emoji: Watermelon
    '√∞≈∏‚Äò‚Äò'   :   ['{CROWN}'       ,],  # emoji: Crown
    '√∞≈∏‚Äú¬±'    :   ['{MOBILE}'      ,],  # emoji: Mobile Phone

    # Emojis with descriptions: medium objects
    '√∞≈∏‚Äò¬ª': ['{GHOST}',],       # emoji: Ghost

    # Emojis with descriptions: large objects
    "√∞≈∏≈°‚Äî"    :   ["{automobile}"  ,],

    # Emojis with descriptions: stellar objects
    "√∞≈∏≈í¬ç"    :   ["{earth}"       ,],
    "√¢Àú‚Ç¨√Ø¬∏¬è"    :   ["{sun}"         ,],

    # even more:
    '√∞≈∏‚Äò‚Ç¨': ['[o o]',], #'{eyes}',  # ASCII: [o o]
    '√∞≈∏‚Äò¬è': ['{clapping}',],  # ASCII: \o/ \o/
    '√∞≈∏‚Äò‚Äú': ['{glasses}',],  # ASCII: 8-)
    '√∞≈∏≈í‚Ñ¢': ['{crescent moon}',],  # ASCII: c)
    '√¢Àú‚Äù': ['{umbrella with rain drops}',],  # ASCII: /\_/\
    '√¢≈ì¬®': ['{sparkles}',],  # ASCII: * *
    '√∞≈∏≈Ω‚Äû': ['{christmas tree}',],  # ASCII: /_\
    '√∞≈∏≈Ω‚Äö': ['{birthday cake}',],  # ASCII: [*]
    '√∞≈∏≈ΩÀÜ': ['{balloon}',],  # ASCII: o
    '√∞≈∏≈Ω¬µ': ['√¢‚Ñ¢¬™√¢‚Ñ¢¬™',],                #surprisingly, this is o.g. 128-char ascii and totally valid
    '√∞≈∏≈íÀÜ': ['{rainbow}',],  # ASCII: ~~~~
    '√¢¬≠¬ê':  ['*','x'],  # ASCII: *
    '√¢¬ù‚Äû√Ø¬∏¬è': ['(*)','(x)'],  # ASCII: *
    '√∞≈∏≈í≈∏': ['{*}','{x}'],  # ASCII: * *
    '√¢≈ì¬ø': ['{flower}',],  # ASCII: @-@
    '√∞≈∏¬ç‚Äû': ['{mushroom}',],  # ASCII: 0+=
    '√∞≈∏≈í¬º': ['{blossom}',],  # ASCII: (@)
    '√∞≈∏≈í¬∏': ['{cherry blossom}',],  # ASCII: (*)
    '√∞≈∏≈í¬ª': ['{sunflower}',],  # ASCII: (")
    '√∞≈∏≈í¬ø': ['{herb}',],  # ASCII: %%%%
    '√∞≈∏¬ç‚Ç¨': ['{4-leaf clover}',],  # ASCII: **^^
    '√∞≈∏≈í¬∑': ['{tulip}',],  # ASCII: @)
    '√∞≈∏¬ç¬Å': ['{maple leaf}',],  # ASCII: ~~~~
    '√∞≈∏‚Äô¬´': ['{dizzy}',],  # ASCII: @-@
    '√∞≈∏≈í¬π': ["@}--'-",],  # ASCII: @) rose
    '√∞≈∏≈í¬∫': ['{hibiscus}',],  # ASCII: @@
    '√∞≈∏≈í¬¥': ['{palm tree}',],  # ASCII: #
    '√∞≈∏≈í¬≤': ['{evergreen tree}',],  # ASCII: T
    '√∞≈∏≈í¬≥': ['{deciduous tree}',],  # ASCII: T
    '√∞≈∏≈í¬µ': ['{cactus}',],  # ASCII: ^^^
    '√∞≈∏¬ç‚Äö': ['{fallen leaf}',],  # ASCII: ~~~
    '√∞≈∏¬ç∆í': ['{leaf fluttering in wind}',],  # ASCII: ~~~
    '√∞≈∏≈í≈†': ['{water wave}',],  # ASCII: ~~~
    '√∞≈∏‚Äù¬•': ['{fire}',],  # ASCII: ~~~~
    '√∞≈∏‚Äô¬ß': ['{droplet}',],  # ASCII: .
    '√∞≈∏‚Äô¬¶': ['{sweat droplets}',],  # ASCII: . .
    '√∞≈∏‚Äô¬®': ['{dashing away}',],  # ASCII: @@
    '√¢Àú¬Å√Ø¬∏¬è': ['{cloud}',],  # ASCII: ~~~
    '√¢‚Ä∫‚Ä¶': ['{sun behind cloud}',],  # ASCII: √¢Àú‚Ç¨~~~
    '√∞≈∏≈í¬´√Ø¬∏¬è': ['{fog}',],  # ASCII: ~~~
    '√∞≈∏≈í¬™√Ø¬∏¬è': ['{tornado}',],  # previously added this twice so wonder if this is working properly or not
    '√∞≈∏≈í¬ß√Ø¬∏¬è': ['{cloud with rain}',],  # ASCII: ~~~
    '√¢≈°¬°': ['{high voltage}',],  # ASCII: @@
    '√∞≈∏≈í‚Ç¨': ['{cyclone}',],  # ASCII: @-@
    '√∞≈∏≈í¬Å': ['{foggy}',],  # ASCII: ~~~
    '√∞≈∏≈í‚Äö': ['{closed umbrella}'],  # ASCII: ---)
    '√∞≈∏‚Äô¬∞': ['{money bag}'],
    '√∞≈∏‚Äô¬µ': ['{paper money}'],

    #pointing
    '√∞≈∏‚Äò‚Ä†'    : ['^^----','{index finger pointing up}',],  # ASCII: ^
    '√∞≈∏‚Äò‚Ä°'    : ['vv----','{index finger pointing down}',],  # ASCII: v
    '√∞≈∏‚ÄòÀÜ'   : ['<-----','{index finger pointing left}',],  # ASCII: <
    '√∞≈∏‚Äò‚Ä∞'   : ['----->','{index finger pointing right}',],  # ASCII: >
    '√¢Àú¬ù√Ø¬∏¬è'    : ['{index pointing up}',],  # ASCII: ^
    '√∞≈∏‚Äì‚Ä¢'    : ['{middle finger}',],  # ASCII: FU
    '√∞≈∏¬§≈æ'    : ['{crossed fingers}',],  # ASCII: @@
    '√∞≈∏‚Äì‚Äì'    : ['{vulcan salute}',],  # ASCII: V
    '√∞≈∏¬§Àú'    : ['\\m/','{metal sign}'],  # ASCII: \m/ {sign of the horns}
    '√∞≈∏¬§‚Ñ¢'    : ['{call me hand}',],  # ASCII: C
    '√∞≈∏‚Äò≈í'    : ['Okay!',],  # ASCII: OK
    '√∞≈∏‚Äò¬ç'    : ['{thumbs up}',],  # ASCII: Y
    '√∞≈∏‚Äò≈Ω'    : ['{thumbs down}',],  # ASCII: N
    '√¢≈ì≈í√Ø¬∏¬è'     : ['{peace/victory sign}','{peace [or victory] hand sign}'],  #apparently editplus isn't encoding this character well enough to work like this
    '\u270c': ['{peace/victory sign}','{peace [or victory] hand sign}'],  #...so we really should be specifying these like this {sigh}. Multiple keys would be better than this duplicatoin.
    '√∞≈∏¬§≈∏'    : ['<3','{heart}'],  # ASCII: ILU
    '√∞≈∏¬§¬è'   : ['{pinching hand}',],  # ASCII: <0>
    '√¢Àú¬Æ√Ø¬∏¬è':['{peace symbol}',],   #this doesn't seem to catch it, it seems to be double-wide and caught by unicode and returned as "{peace_symbol}"

    #regional indicator codes that are basically just subscript letters
    "√∞≈∏‚Ä°¬¶":     ["A",],
    "√∞≈∏‚Ä°¬ß":    ["B",],
    "√∞≈∏‚Ä°¬®":    ["C",],
    "√∞≈∏‚Ä°¬©":    ["D",],
    "√∞≈∏‚Ä°¬™":    ["E",],
    "√∞≈∏‚Ä°¬´":     ["F",],
    "√∞≈∏‚Ä°¬≠":    ["H",],
    "√∞≈∏‚Ä°¬Ø":    ["J",],
    "√∞≈∏‚Ä°¬∞":    ["K",],
    "√∞≈∏‚Ä°¬±":    ["L",],
    "√∞≈∏‚Ä°¬≤":   ["M",],
    "√∞≈∏‚Ä°¬≥":    ["N",],
    "√∞≈∏‚Ä°¬¥":    ["O",],
    "√∞≈∏‚Ä°¬µ":    ["P",],
    "√∞≈∏‚Ä°¬∂":    ["Q",],
    "√∞≈∏‚Ä°¬∑":    ["R",],
    "√∞≈∏‚Ä°¬∏":    ["S",],
    "√∞≈∏‚Ä°¬π":    ["T",],
    "√∞≈∏‚Ä°¬∫":    ["U",],
    "√∞≈∏‚Ä°¬Ω":    ["X",],
    "√∞≈∏‚Ä°¬ø":    ["Z",],

    '\uE0048':["H"],                #Latin Capital Letter H
    '\ue0069':["i"],                #Latin Small Letter I
    '\uE005A':["Z"],                #Latin Capital Letter Z
    '\ue006c':["l"],                #Latin Small Letter L
    '\uE004D':["M"],                #Latin Capital Letter M
    '\uE004C':["L"],                #Latin Capital Letter L
    '\ue0061':["a"],                #Latin Small Letter a
    '\uE0057':["W"],                #Latin Capital Letter W
    '\ue0063':["c"],                #Latin Small Letter C
    '\uE0047':["G"],                #Latin Capital Letter G
    '\ue006d':["m"],                #Latin Small Letter M
    '\ue0064':["d"],                #Latin Small Letter D
    '\ue0067':["g"],                #Latin Small Letter G
    '\uE0051':["Q"],                #Latin Capital Letter Q
    '\uE0045':["E"],                #Latin Capital Letter E
    '\uE004A':["J"],                #Latin Capital Letter J
    '\ue0070':["p"],                #Latin Small Letter P
    '\uE0052':["R"],                #Latin Capital Letter R
    '\uE0050':["P"],                #Latin Capital Letter P
    '\ue0078':["x"],                #Latin Small Letter X
    '\uE0056':["V"],                #Latin Capital Letter V
    '\ue007a':["z"],                #Latin Small Letter Z
    '\ue0066':["f"],                #Latin Small Letter F
    '\uE0058':["X"],                #Latin Capital Letter X
    '\ue0076':["v"],                #Latin Small Letter V
    '\uE0059':["Y"],                #Latin Capital Letter Y
    '\ue0065':["e"],                #Latin Small Letter E
    '\uE0049':["I"],                #Latin Capital Letter I
    '\uE0055':["U"],                #Latin Capital Letter U
    '\ue0073':["s"],                #Latin Small Letter S
    '\uE0053':["S"],                #Latin Capital Letter S
    '\ue006f':["o"],                #Latin Small Letter O
    '\ue0071':["q"],                #Latin Small Letter Q
    '\ue006b':["k"],                #Latin Small Letter K
    '\uE004E':["N"],                #Latin Capital Letter N
    '\ue0077':["w"],                #Latin Small Letter W
    '\uE0054':["T"],                #Latin Capital Letter T
    '\uE004B':["K"],                #Latin Capital Letter K
    '\ue0072':["r"],                #Latin Small Letter R
    '\uE0044':["D"],                #Latin Capital Letter D
    '\ue0068':["h"],                #Latin Small Letter H
    '\uE004F':["O"],                #Latin Capital Letter O
    '\ue006e':["n"],                #Latin Small Letter N
    '\ue0079':["y"],                #Latin Small Letter Y
    '\ue0075':["u"],                #Latin Small Letter U
    '\uE0041':["a"],                #Latin Capital Letter a
    '\uE0042':["B"],                #Latin Capital Letter B
    '\uE0046':["F"],                #Latin Capital Letter F
    '\uE0043':["C"],                #Latin Capital Letter C
    '\ue0062':["b"],                #Latin Small Letter B
    '\ue006a':["j"],                #Latin Small Letter J
    '\ue0074':["t"],                #Latin Small Letter T           #failed as hash key
    'code ue0074':["t"],            #Latin Small Letter T


    #the most puzzling thing i've found - this character was completely invisible in Windows Explorer file view (Windows 10, 2023/05/28)
    #as well as not copy-pastable (unlike all the others), so we couldn't even google it
    #it is called "ZERO WIDTH JOINER" and used in Indian languages: https://www.fileformat.info/info/unicode/char/200d/index.htm
    '\u200d': ['|',' '],  #deciding what to do with this character was difficult

    #these mfs exposed a python bug where certain characters aren't usable as keys in a dictionary
        '\u1f1fe': ["Y",],                      #python bug?! - can't use this as a dictionary table key?!?! hash key failure?!?!
    'code u1f1fe': ["Y",],                          #workaround
        '\u008d√Ç¬ç' : ["{reverse line feed}",],    #python bug?! - can't use this as a dictionary table key?!?! hash key failure?!?!
    'code u008d' : ["{reverse line feed}",],        #workaround



    #2023 stuff that breaks our shit in the wild
    '√¢‚Ñ¢¬´': ['{music}','{music}',],                         #metaflac can't work with filenames that have this character in them so we're treating this harshly
    "'": ["'"],                             #is this a unicode apostrophe?
    "√∞≈∏‚Äù≈æ":     ["{adults only!}",],
    "√∞≈∏¬ç‚Äô":     ["{cherry}",],
    "√∞≈∏‚Äò‚Ñ¢":     ["{bikini}",],
    "√∞≈∏‚Äú¬ç":     ["{pushpin}",],
    "√∞≈∏¬ç‚Ä†":     ["{eggplant}",],
    "√∞≈∏¬ç‚Äò":     ["{peach}",],
    "√∞≈∏¬è¬≥":     ["{waving flag}",],
    "√∞≈∏‚Äô‚Äπ":     ["{lips}",],
    "√∞≈∏‚Äô‚Äû":     ["{lipstick}",],
    "√∞≈∏‚Äò¬∏":     ["{princess}",],
    "√¢Àú‚Ä†":     ["*","{star}",],
    "√¢≈ì¬ß":     ["*","{star}",],
    "√∞≈∏‚Äî¬ù":     ["{key}",],
    "√∞≈∏‚Ä¢¬∏":     ["{spider web}",],
    "√∞≈∏≈°‚Ç¨":     ["{rocket ship}",],
    "√∞≈∏¬ê¬ê":     ["{goat}",],
    "√∞≈∏¬è‚Ä†":     ["{trophy}",],
    "√∞≈∏¬ê‚Ñ¢":     ["{octopus}",],
    "√∞≈∏‚Äô¬•":     ["{collision symbol}",],
    "√∞≈∏¬è¬•":     ["{hospital}",],
    "√∞≈∏¬¶‚Ä°":     ["{bat}",],
    "√¢‚Ñ¢‚Ä∫":     ["{crown}",],
    "√∞≈∏¬è¬ª":     ["{pale skin tone}",],
    "√∞≈∏¬•‚Ç¨":     ["{wilted flower}",],
    "√∞≈∏‚Äô≈Ω":     ["{gem stone}",],
    "√∞≈∏≈Ω‚Ç¨":     ["{ribbon}",],
    "√∞≈∏≈í¬§":     ["{white sun with small cloud}",],
    "√∞≈∏¬¶≈†":     ["{fox face}",],
    "√∞≈∏¬è¬º":     ["{cream white skin}",],
    "√∞≈∏‚Äò¬∞":     ["{person with veil}",],
    "√∞≈∏¬ê¬∞":     ["{rabbit face}",],
    "√∞≈∏¬ê‚Ä°":     ["{rabbit}",],
    '\ue0067':["E","g"],
    '\u1faf6':["{heart hands}",],
    '√≥¬†¬Å¬ß':       ["g",],     #editplus didn't this character when pasted, but it worked, but later seems to have changed, so expect failure
    '√≥¬†¬Å¬¢':       ["b",],     #editplus didn't this character when pasted, but it worked, but later seems to have changed, so expect failure
    '√≥¬†¬Å¬≥':       ["s",],     #editplus didn't this character when pasted, but it worked, but later seems to have changed, so expect failure
    '√≥¬†¬Å¬£':       ["c",],     #editplus didn't this character when pasted, but it worked, but later seems to have changed, so expect failure
    '√≥¬†¬Å¬ø':       ["{cancelled!}",],
    '\u0081':    ["{control}",],
    '\u0090':    ["{device control}",],
    '\u008F':    ["3",],                                  #"single shift 3"
    '\ud83d':    ["{smiling face with open mouth}"],
    'code ud83d':["{smiling face with open mouth}"],
    "\u1f409":   ["{dragon}",],
    "code u1f409":["{dragon}",],
    "√∞≈∏¬¶‚Äπ":      ["{butterfly}",],
    "√∞≈∏‚Äù‚Äî":      ["{chain link}",],
    "√∞≈∏¬ß¬®":      ["{firecracker}",],
    "√Ø¬∏¬è√¢‚Ñ¢¬•√Ø¬∏¬è":   ["<3","{heart}"],
    "√¢‚Ñ¢‚Ä¢":       ["{crown}",],
    "√∞≈∏¬ê¬Ø":       ["{tiger face}",],
    "√∞≈∏‚Äô¬∏":      ["{money with wings}",],
    "üéâ":        ["{party popper}",],
    #"":      ["",],
    #"":      ["",],
    #"":      ["",],
    #"":      ["",],
    #"":      ["",],
    #"":      ["",],
    #"":      ["",],
    #"":      ["",],


}


if __name__ == "__main__":
    #we do this only in main because otherwise it affects loading modules
    original_print = print                                      # Store the original print function before overriding
    builtins.print = print_error                                # Override the built-in print function with the custom one

    main()


